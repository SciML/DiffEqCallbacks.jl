<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantification · DiffEqCallbacks.jl</title><meta name="title" content="Uncertainty Quantification · DiffEqCallbacks.jl"/><meta property="og:title" content="Uncertainty Quantification · DiffEqCallbacks.jl"/><meta property="twitter:title" content="Uncertainty Quantification · DiffEqCallbacks.jl"/><meta name="description" content="Documentation for DiffEqCallbacks.jl."/><meta property="og:description" content="Documentation for DiffEqCallbacks.jl."/><meta property="twitter:description" content="Documentation for DiffEqCallbacks.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqCallbacks/stable/uncertainty_quantification/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqCallbacks/stable/uncertainty_quantification/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqCallbacks/stable/uncertainty_quantification/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DiffEqCallbacks.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffEqCallbacks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../output_saving/">Output and Saving Controls</a></li><li><a class="tocitem" href="../integrating/">Numerical Integration Callbacks</a></li><li><a class="tocitem" href="../timed_callbacks/">Timed Callbacks</a></li><li><a class="tocitem" href="../steady_state/">Steady State Callbacks</a></li><li><a class="tocitem" href="../step_control/">Step Control Callbacks</a></li><li><a class="tocitem" href="../projection/">Manifold Projection</a></li><li class="is-active"><a class="tocitem" href>Uncertainty Quantification</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-FitzHugh-Nagumo"><span>Example 1: FitzHugh-Nagumo</span></a></li><li><a class="tocitem" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo"><span>Example 2: Adaptive ProbInts on FitzHugh-Nagumo</span></a></li><li><a class="tocitem" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor"><span>Example 3: Adaptive ProbInts on the Lorenz Attractor</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Uncertainty Quantification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty Quantification</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqCallbacks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqCallbacks.jl/blob/master/docs/src/uncertainty_quantification.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Uncertainty-Quantification"><a class="docs-heading-anchor" href="#Uncertainty-Quantification">Uncertainty Quantification</a><a id="Uncertainty-Quantification-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-Quantification" title="Permalink"></a></h1><p>The following callbacks are designed to help enable uncertainty quantification of the differential equation solutions.</p><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.ProbIntsUncertainty"><a class="docstring-binding" href="#DiffEqCallbacks.ProbIntsUncertainty"><code>DiffEqCallbacks.ProbIntsUncertainty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ProbIntsUncertainty(σ, order, save = true)</code></pre><p>The <a href="https://arxiv.org/abs/1506.04592">ProbInts</a> method for uncertainty quantification involves the transformation of an ODE into an associated SDE where the noise is related to the timesteps and the order of the algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>σ</code> is the noise scaling factor. It is recommended that <code>σ</code> is representative of the size of the errors in a single step of the equation. If such a value is unknown, it can be estimated automatically in adaptive time-stepping algorithms via AdaptiveProbIntsUncertainty</li><li><code>order</code> is the order of the ODE solver algorithm.</li><li><code>save</code> is for choosing whether this callback should control the saving behavior. Generally this is true unless one is stacking callbacks in a <code>CallbackSet</code>.</li></ul><p><strong>References</strong></p><p>Conrad P., Girolami M., Särkkä S., Stuart A., Zygalakis. K, Probability Measures for Numerical Solutions of Differential Equations, arXiv:1506.04592</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqCallbacks.jl/blob/c3932cbc9113733c63c29bbce83c928bfaf968dc/src/probints.jl#L9-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DiffEqCallbacks.AdaptiveProbIntsUncertainty"><a class="docstring-binding" href="#DiffEqCallbacks.AdaptiveProbIntsUncertainty"><code>DiffEqCallbacks.AdaptiveProbIntsUncertainty</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">AdaptiveProbIntsUncertainty(order, save = true)</code></pre><p>The <a href="https://arxiv.org/abs/1506.04592">ProbInts</a> method for uncertainty quantification involves the transformation of an ODE into an associated SDE where the noise is related to the timesteps and the order of the algorithm.</p><p><code>AdaptiveProbIntsUncertainty</code> is a more automated form of <code>ProbIntsUncertainty</code> which uses the error estimate from within adaptive time stepping methods to estimate <code>σ</code> at every step.</p><p><strong>Arguments</strong></p><ul><li><code>order</code> is the order of the ODE solver algorithm.</li><li><code>save</code> is for choosing whether this callback should control the saving behavior. Generally this is true unless one is stacking callbacks in a <code>CallbackSet</code>.</li></ul><p><strong>References</strong></p><p>Conrad P., Girolami M., Särkkä S., Stuart A., Zygalakis. K, Probability Measures for Numerical Solutions of Differential Equations, arXiv:1506.04592</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/DiffEqCallbacks.jl/blob/c3932cbc9113733c63c29bbce83c928bfaf968dc/src/probints.jl#L46-L69">source</a></section></details></article><h2 id="Example-1:-FitzHugh-Nagumo"><a class="docs-heading-anchor" href="#Example-1:-FitzHugh-Nagumo">Example 1: FitzHugh-Nagumo</a><a id="Example-1:-FitzHugh-Nagumo-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-FitzHugh-Nagumo" title="Permalink"></a></h2><p>In this example we will determine our uncertainty when solving the FitzHugh-Nagumo model with the <code>Euler()</code> method. We define the FitzHugh-Nagumo model:</p><pre><code class="language-julia hljs">using DiffEqCallbacks, OrdinaryDiffEq, Plots
gr(fmt = :png)

function fitz(du, u, p, t)
    V, R = u
    a, b, c = p
    du[1] = c * (V - V^3 / 3 + R)
    du[2] = -(1 / c) * (V - a - b * R)
end
u0 = [-1.0; 1.0]
tspan = (0.0, 20.0)
p = (0.2, 0.2, 3.0)
prob = ODEProblem(fitz, u0, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 20.0)
u0: 2-element Vector{Float64}:
 -1.0
  1.0</code></pre><p>Now we define the <code>ProbInts</code> callback. In this case, our method is the <code>Euler</code> method and thus it is order 1. For the noise scaling, we will try a few different values and see how it changes. For <code>σ=0.2</code>, we define the callback as:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.2, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SciMLBase.DiscreteCallback{DiffEqCallbacks.var&quot;#ProbIntsUncertainty##0#ProbIntsUncertainty##1&quot;, DiffEqCallbacks.ProbIntsCache{Float64}, typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT), Nothing, Tuple{}}(DiffEqCallbacks.var&quot;#ProbIntsUncertainty##0#ProbIntsUncertainty##1&quot;(), DiffEqCallbacks.ProbIntsCache{Float64}(0.2, 1), SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 0], nothing, ())</code></pre><p>This is akin to having an error of approximately 0.2 at each step. We now build and solve a <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/ensemble/">EnsembleProblem</a> for 100 trajectories:</p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Euler(), trajectories = 100, callback = cb, dt = 1 / 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 100 with uType:
SciMLBase.ODESolution{Float64, 2, Vector{Vector{Float64}}, Nothing, Nothing, Vector{Float64}, Vector{Vector{Vector{Float64}}}, Nothing, SciMLBase.ODEProblem{Vector{Float64}, Tuple{Float64, Float64}, true, Tuple{Float64, Float64, Float64}, SciMLBase.ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Tuple{Float64, Float64, Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Tuple{Float64, Float64, Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Tuple{Float64, Float64, Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Tuple{Float64, Float64, Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Nothing, @NamedTuple{}}, SciMLBase.StandardODEProblem}, OrdinaryDiffEqLowOrderRK.Euler, OrdinaryDiffEqCore.InterpolationData{SciMLBase.ODEFunction{true, SciMLBase.AutoSpecialize, FunctionWrappersWrappers.FunctionWrappersWrapper{Tuple{FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{Float64}, Vector{Float64}, Tuple{Float64, Float64, Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Tuple{Float64, Float64, Float64}, Float64}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{Float64}, Tuple{Float64, Float64, Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}, FunctionWrappers.FunctionWrapper{Nothing, Tuple{Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Vector{ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}, Tuple{Float64, Float64, Float64}, ForwardDiff.Dual{ForwardDiff.Tag{DiffEqBase.OrdinaryDiffEqTag, Float64}, Float64, 1}}}}, false}, LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing, Nothing, Nothing}, Vector{Vector{Float64}}, Vector{Float64}, Vector{Vector{Vector{Float64}}}, Nothing, OrdinaryDiffEqLowOrderRK.EulerCache{Vector{Float64}, Vector{Float64}}, Nothing}, SciMLBase.DEStats, Nothing, Nothing, Nothing, Nothing}</code></pre><p>Now we can plot the resulting Monte Carlo solution:</p><pre><code class="language-julia hljs">plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="9af08c56.svg" alt="Example block output"/><p>If we increase the amount of error, we see that some parts of the equation have less uncertainty than others. For example, at <code>σ=0.5</code>:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.5, 1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Euler(), trajectories = 100, callback = cb, dt = 1 / 10)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="b2bcb679.svg" alt="Example block output"/><p>But at this amount of noise, we can see how we contract to the true solution by decreasing <code>dt</code>:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.5, 1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Euler(), trajectories = 100, callback = cb, dt = 1 / 100)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="9a6ce4d5.svg" alt="Example block output"/><h2 id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo"><a class="docs-heading-anchor" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a><a id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo" title="Permalink"></a></h2><p>While the first example is academic and shows how the ProbInts method scales, the fact that one should have some idea of the error in order to calibrate <code>σ</code> can lead to complications. Thus the more useful method in many cases, is the <code>AdaptiveProbIntsUncertainty</code> version. In this version, no <code>σ</code> is required since this is calculated using an internal error estimate. Thus this gives an accurate representation of the possible error without user input.</p><p>Let&#39;s try this with the order 5 <code>Tsit5()</code> method on the same problem as before:</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob, Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Tsit5(), trajectories = 100, callback = cb)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="beb678eb.svg" alt="Example block output"/><p>In this case, we see that the default tolerances give us a very good solution. However, if we increase the tolerance a lot:</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob, Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Tsit5(), trajectories = 100, callback = cb, abstol = 1e-3,
    reltol = 1e-1)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="7c3320b7.svg" alt="Example block output"/><p>we can see that the moments just after the rise can be uncertain.</p><h2 id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor"><a class="docs-heading-anchor" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor">Example 3: Adaptive ProbInts on the Lorenz Attractor</a><a id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor" title="Permalink"></a></h2><p>One very good use of uncertainty quantification is on chaotic models. Chaotic equations diverge from the true solution according to the error exponentially. This means that as time goes on, you get further and further from the solution. The <code>ProbInts</code> method can help diagnose how much of the timeseries is reliable.</p><p>As in the previous example, we first define the model:</p><pre><code class="language-julia hljs">function g(du, u, p, t)
    du[1] = p[1] * (u[2] - u[1])
    du[2] = u[1] * (p[2] - u[3]) - u[2]
    du[3] = u[1] * u[2] - p[3] * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 30.0)
p = [10.0, 28.0, 8 / 3]
prob = ODEProblem(g, u0, tspan, p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 30.0)
u0: 3-element Vector{Float64}:
 1.0
 0.0
 0.0</code></pre><p>and then we build the <code>ProbInts</code> type. Let&#39;s use the order 5 <code>Tsit5</code> again.</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SciMLBase.DiscreteCallback{DiffEqCallbacks.var&quot;#AdaptiveProbIntsUncertainty##0#AdaptiveProbIntsUncertainty##1&quot;, DiffEqCallbacks.AdaptiveProbIntsCache, typeof(SciMLBase.INITIALIZE_DEFAULT), typeof(SciMLBase.FINALIZE_DEFAULT), Nothing, Tuple{}}(DiffEqCallbacks.var&quot;#AdaptiveProbIntsUncertainty##0#AdaptiveProbIntsUncertainty##1&quot;(), DiffEqCallbacks.AdaptiveProbIntsCache(5), SciMLBase.INITIALIZE_DEFAULT, SciMLBase.FINALIZE_DEFAULT, Bool[1, 0], nothing, ())</code></pre><p>Then we solve the <code>MonteCarloProblem</code></p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Tsit5(), trajectories = 100, callback = cb)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="adc3cc43.svg" alt="Example block output"/><p>Here we see that by <code>t</code> about 22 we start to receive strong deviations from the &quot;true&quot; solution. We can increase the amount of time before error explosion by using a higher order method with stricter tolerances:</p><pre><code class="language-julia hljs">tspan = (0.0, 40.0)
prob = ODEProblem(g, u0, tspan, p)
cb = AdaptiveProbIntsUncertainty(7)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob, Vern7(), trajectories = 100, callback = cb, reltol = 1e-6)
plot(sim, idxs = (0, 1), linealpha = 0.4)</code></pre><img src="bb139e20.svg" alt="Example block output"/><p>we see that we can extend the amount of time until we deviate strongly from the &quot;true&quot; solution. Of course, for a chaotic system like the Lorenz one presented here, it is impossible to follow the true solution for long times, due to the fact that the system is chaotic and unavoidable deviations due to the numerical precision of a computer get amplified exponentially.</p><p>However, not all hope is lost. The <a href="http://mathworld.wolfram.com/ShadowingTheorem.html">shadowing theorem</a> is a strong statement for having confidence in numerical evolution of chaotic systems:</p><blockquote><p>Although a numerically computed chaotic trajectory diverges exponentially from the true trajectory with the same initial coordinates, there exists an errorless trajectory with a slightly different initial condition that stays near (&quot;shadows&quot;) the numerically computed one.</p></blockquote><p>For more info on the shadowing theorem, please see the book <em>Chaos in Dynamical Systems</em> by E. Ott.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../projection/">« Manifold Projection</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 13:09">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
